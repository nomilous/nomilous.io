// Generated by CoffeeScript 1.6.3
module.exports = function(id, hostname, port) {
  /* browser-side*/

  var Promise, THREE, aspect, bluriness, camera, canvas, client, container, dom, far, fov, height, near, radianRatio, radius, renderer, rotationX, rotationY, scene, toLatitude, toLongitude, transform, width, xhr;
  dom = require('dom');
  THREE = require('three');
  require('three-postprocessing');
  xhr = require('xhr');
  Promise = require('promise');
  client = require('vertex-client');
  container = dom('body').append('<div></div>').css({
    position: 'absolute',
    width: '100%',
    height: '100%',
    top: '0px',
    left: '0px'
  });
  width = 800;
  height = 600;
  fov = 65;
  aspect = width / height;
  near = 0.1;
  far = 2000;
  bluriness = 1;
  rotationX = 0.003;
  rotationY = 0.03;
  renderer = new THREE.WebGLRenderer({
    antialias: false,
    alpha: false
  });
  scene = new THREE.Scene;
  camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  scene.add(camera);
  camera.position.z = 750;
  scene.fog = new THREE.FogExp2(0x251d15, 0.0018);
  renderer.setSize(width, height);
  renderer.setClearColor(0x050505, 1);
  canvas = renderer.domElement;
  container.append(canvas);
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  radianRatio = Math.PI / 180;
  radius = 300;
  toLongitude = new THREE.Matrix4;
  toLatitude = new THREE.Matrix4;
  transform = function(longitude, latitude) {
    var vector;
    vector = new THREE.Vector3(0.0, 0.0, radius);
    toLongitude.makeRotationY(longitude * radianRatio);
    toLatitude.makeRotationX(-latitude * radianRatio);
    vector.applyMatrix4(toLatitude);
    vector.applyMatrix4(toLongitude);
    return vector;
  };
  return Promise.all(['/earth', '/visitors'].map(function(path) {
    return new Promise(function(resolve, reject) {
      return xhr({
        method: 'GET',
        url: path + ("?id=" + id)
      }, function(_arg) {
        var response, status;
        status = _arg.status, response = _arg.response;
        if (status === 200) {
          return resolve(JSON.parse(response));
        }
        return reject(new Error("" + path + " error status", status));
      }, reject);
    });
  })).then(function(_arg) {
    var animate, city, composer, country, earth, elem, geometry, i, labelGeom, labelLine, labelMat, landMasses, lastPass, ll, material, me, particles, persons, polygon, position, projector, region, renderModel, text, updateLocation, vertex, visitors, _i, _j, _k, _len, _len1, _len2, _ref;
    earth = _arg[0], visitors = _arg[1];
    landMasses = [];
    for (_i = 0, _len = earth.length; _i < _len; _i++) {
      polygon = earth[_i];
      material = new THREE.LineBasicMaterial({
        color: 0xffffff
      });
      geometry = new THREE.Geometry;
      i = 0;
      for (_j = 0, _len1 = polygon.length; _j < _len1; _j++) {
        vertex = polygon[_j];
        if (i++ % 4 !== 0) {
          continue;
        }
        geometry.vertices.push(transform(vertex[0], vertex[1]));
      }
      landMasses.push(polygon = new THREE.Line(geometry, material));
      scene.add(polygon);
    }
    persons = [];
    updateLocation = function(person) {
      var adjustHeight, adjustWidth, x, y;
      vertex = person.line.geometry.vertices[1].clone();
      vertex.applyMatrix4(person.line.matrixWorld);
      projector.projectVector(vertex, camera);
      x = (vertex.x + 1) / 2 * canvas.width;
      y = -(vertex.y - 1) / 2 * canvas.height;
      adjustHeight = 10;
      adjustWidth = person.text.length * 2;
      x -= adjustWidth;
      y -= adjustHeight;
      return person.elem.css({
        top: "" + y + "px",
        left: "" + x + "px"
      });
    };
    material = new THREE.ParticleBasicMaterial({
      color: 0xffffff,
      size: 8,
      fog: false
    });
    geometry = new THREE.Geometry;
    particles = new THREE.ParticleSystem(geometry, material);
    projector = new THREE.Projector;
    scene.add(particles);
    for (_k = 0, _len2 = visitors.length; _k < _len2; _k++) {
      _ref = visitors[_k], country = _ref.country, region = _ref.region, city = _ref.city, ll = _ref.ll, me = _ref.me;
      position = transform(ll[1], ll[0]);
      if (true) {
        labelGeom = new THREE.Geometry;
        labelMat = new THREE.LineBasicMaterial({
          color: 0xffffff
        });
        labelGeom.vertices.push(position);
        labelGeom.vertices.push(position.clone().multiplyScalar(1.3));
        scene.add(labelLine = new THREE.Line(labelGeom, labelMat));
        text = "" + city + ", " + region + ", " + country;
        elem = container.append("<div>" + text + "</div>").css({
          color: '#cccccc',
          'font-size': 'xx-small',
          position: 'absolute',
          top: '0px',
          left: '0px'
        });
        persons.push({
          text: text,
          elem: elem,
          line: labelLine
        });
      }
      geometry.vertices.push(position);
    }
    animate = function() {
      var person, _l, _len3, _len4, _m, _results;
      try {
        requestAnimationFrame(animate);
      } catch (_error) {}
      if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        camera.aspect = canvas.width / canvas.height;
        camera.updateProjectionMatrix();
        renderer.setSize(canvas.width, canvas.height);
        composer.setSize(canvas.width, canvas.height);
      }
      composer.render(0.1);
      for (_l = 0, _len3 = landMasses.length; _l < _len3; _l++) {
        polygon = landMasses[_l];
        polygon.rotation.x += rotationX;
        polygon.rotation.y += rotationY;
      }
      particles.rotation.x += rotationX;
      particles.rotation.y += rotationY;
      _results = [];
      for (_m = 0, _len4 = persons.length; _m < _len4; _m++) {
        person = persons[_m];
        person.line.rotation.x += rotationX;
        person.line.rotation.y += rotationY;
        _results.push(updateLocation(person));
      }
      return _results;
    };
    renderModel = new THREE.RenderPass(scene, camera);
    lastPass = new THREE.ShaderPass(THREE.CopyShader);
    lastPass.renderToScreen = true;
    composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderModel);
    composer.addPass(lastPass);
    return animate();
  }, function(error) {
    return console.log(error);
  });
};
