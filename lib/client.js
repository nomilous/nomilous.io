// Generated by CoffeeScript 1.6.3
module.exports = function() {
  /* browser-side*/

  var Promise, THREE, aspect, camera, container, dom, far, fov, height, near, radianRatio, radius, renderer, scene, toLatitude, toLongitude, transform, width, xhr;
  dom = require('dom');
  THREE = require('three');
  xhr = require('xhr');
  Promise = require('promise');
  container = dom('body').append('<div></div>');
  width = 800;
  height = 800;
  fov = 60;
  aspect = width / height;
  near = 0.1;
  far = 2000;
  renderer = new THREE.WebGLRenderer;
  camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  scene = new THREE.Scene;
  scene.fog = new THREE.FogExp2(0x251d15, 0.0018);
  scene.add(camera);
  camera.position.z = 650;
  renderer.setSize(width, height);
  renderer.setClearColor(0x222222, 1);
  container.append(renderer.domElement);
  radianRatio = Math.PI / 180;
  radius = 300;
  toLongitude = new THREE.Matrix4;
  toLatitude = new THREE.Matrix4;
  transform = function(longitude, latitude) {
    var vector;
    vector = new THREE.Vector3(0.0, 0.0, radius);
    toLongitude.makeRotationY(longitude * radianRatio);
    toLatitude.makeRotationX(-latitude * radianRatio);
    vector.applyMatrix4(toLatitude);
    vector.applyMatrix4(toLongitude);
    return vector;
  };
  return Promise.all(['/earth', '/visitors'].map(function(path) {
    return new Promise(function(resolve, reject) {
      return xhr({
        method: 'GET',
        url: path
      }, function(_arg) {
        var response, status;
        status = _arg.status, response = _arg.response;
        if (status === 200) {
          return resolve(JSON.parse(response));
        }
        return reject(new Error("" + path + " error status", status));
      }, reject);
    });
  })).then(function(_arg) {
    var animate, earth, geometry, landMasses, material, polygon, shape, vertex, vertices, visitors, _i, _j, _len, _len1, _ref;
    earth = _arg[0], visitors = _arg[1];
    landMasses = [];
    _ref = earth.shapes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      shape = _ref[_i];
      material = new THREE.LineBasicMaterial({
        color: 0xffffff
      });
      geometry = new THREE.Geometry;
      vertices = shape.vertices;
      for (_j = 0, _len1 = vertices.length; _j < _len1; _j++) {
        vertex = vertices[_j];
        geometry.vertices.push(transform(vertex[0], vertex[1]));
      }
      landMasses.push(polygon = new THREE.Line(geometry, material));
      scene.add(polygon);
    }
    animate = function() {
      var _k, _l, _len2, _len3, _results;
      try {
        requestAnimationFrame(animate);
      } catch (_error) {}
      renderer.render(scene, camera);
      for (_k = 0, _len2 = landMasses.length; _k < _len2; _k++) {
        polygon = landMasses[_k];
        polygon.rotation.y += 0.03;
      }
      _results = [];
      for (_l = 0, _len3 = landMasses.length; _l < _len3; _l++) {
        polygon = landMasses[_l];
        _results.push(polygon.rotation.x += 0.003);
      }
      return _results;
    };
    return animate();
  }, function(error) {
    return console.log(error);
  });
};
